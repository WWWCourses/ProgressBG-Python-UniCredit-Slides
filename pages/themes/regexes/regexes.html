<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>regexes</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <!-- css & themes include -->
  <link rel="stylesheet" href="/ProgressBG-Python-UniCredit-Slides/lib/reveal.js/css/reveal.css">
  <link rel="stylesheet" href="/ProgressBG-Python-UniCredit-Slides/outfit/css/themes/dark.css" id="theme">
  <!-- Printing and PDF exports -->
  <script>
    var link = document.createElement( 'link' );
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = window.location.search.match( /print-pdf/gi ) ? '/ProgressBG-Python-UniCredit-Slides/lib/reveal.js/css/print/pdf.css' : '/ProgressBG-Python-UniCredit-Slides/lib/reveal.js/css/print/paper.css';
    document.getElementsByTagName( 'head' )[0].appendChild( link );
  </script>
  <!--[if lt IE 9]>
  <script src="lib/js/html5shiv.js"></script>
  <![endif]-->
  <!-- CUSTOM -->
  <base target="_blank">
</head>
<body>
  <div class="reveal default center" data-transition-speed="default" data-background-transition="default">
    <div class="top_links">
      <a class="home_link" href="/ProgressBG-Python-UniCredit-Slides/pages/agenda/agenda.html#regexes" target="_top"><i class="fa fa-home"></i></a>
      <span class="help_link" href="#"><i class="fa fa-question"></i></span>
      <div class="help_text">
        <div><span>N/Space</span><span>следващ слайд</span></div>
        <div><span>P</span><span>предишен слайд</span></div>
        <div><span>O</span><span>всички слайдове</span></div>
        <div><span>ctrl+left click</span><span>увеличава елемента</span></div>
      </div>
    </div>
    <div class="footer theme_switch">
      <a href="#" onclick="document.getElementById('theme').setAttribute('href','/ProgressBG-Python-UniCredit-Slides/outfit/css/themes/dark.css'); return false;">Dark</a>
      <a href="#" onclick="document.getElementById('theme').setAttribute('href','/ProgressBG-Python-UniCredit-Slides/outfit/css/themes/light.css'); return false;">Light</a>
      <a href="#" onclick="document.getElementById('theme').setAttribute('href','/ProgressBG-Python-UniCredit-Slides/outfit/css/themes/projector.css'); return false;">Projector</a>
    </div>
    <div class="slides">
<!--
########################################################
##################### SLIDES START #####################
########################################################
-->
<section data-min-total="80"><h1>Regular Expressions in Python</h1></section>
<section data-transition="zoom">
  <!-- linkedin badge -->
  <!--<script type="text/javascript" src="https://platform.linkedin.com/badges/js/profile.js" async defer></script>-->
  <section class="copyright" data-transition="zoom">
    <div class="note">
      <p>Created for</p>
    </div>
    <div class="company">
      <a href="http://progressbg.net/програмиране-с-python-2/">
      <img style="height:80%" src="/ProgressBG-Python-UniCredit-Slides/outfit/images/logos/ProgressBG_logo_529_127.png">
      </a>
    </div>
    <div class="author">
      <span class="note">Iva E. Popova, 2021,</span>
      <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"></a>
    </div>
  </section>
  <section class="copyright" data-transition="zoom" style="margin-top: -2em;">
    <div class="company">
       <div class="LI-profile-badge"  data-version="v1" data-size="large" data-locale="en_US" data-type="vertical" data-theme="dark" data-vanity="ivapopova"><a class="LI-simple-link" href='https://bg.linkedin.com/in/ivapopova?trk=profile-badge'>Iva E. Popova on LinkedIn</a></div>
    </div>
  </section>
</section>

<section data-min="20"><h1>Regular Expressions Basis</h1></section>
<section><h2>Regular Expressions Basis</h2>
  <section><h3>Overview</h3>
    <dl class="fa">
      <dt>Regular Expression synonyms:</dt>
      <dd data-tooltip="/\breg(?:ular\s*)?exp?(?:ression)?\b/i">Regex, RegEx, RegExp</dd>
      <dt>Regular Expression is a <span class="note">string pattern</span>, which can match or not other stings</dt>
      <dt>You can think of it a as a kind of search mechanism.</dt>
    </dl>
  </section>
  <section>
    <pre><code rel="Python3" class="python">
      import re

      # the string to search with regex:
      user_email = "prefix@domain.com"

      # the regex to find if the userEmail contains '@' symbol:
      regex = re.compile(r'@')

      # do the match test:
      if regex.search(user_email):
        print("Match!")
      else:
        print("No match!")
    </code></pre>
  </section>
  <section><h3>the language</h3>
    <dl class="fa">
      <dt>You can think of Regular Expressions as a separate language, with its own rules and specs.</dt>
      <dt>In fact, the Regular Expressions are coming from the <span class="note">regular language</span> defined by <a href="https://en.wikipedia.org/wiki/Stephen_Cole_Kleene">Kleene</a> in the early 1950s</dt>
      <dt>Nowadays, almost all programming languages implements the concept of Regex.</dt>
    </dl>
  </section>
  <section>
    <dl class="fa">
      <dt>A regex grammar includes 2 types of symbols:</dt>
      <dd><span class="note">Regular symbols</span>: they are matched literally on the matching string</dd>
      <dd><span class="note">Meta-characters</span>: they have special meaning and gives the power of regex</dd>
      <pre><code rel="complete list of regex metacharacters" class="python" data-noescape>

        <span style="font-size: 1.5em;line-height:1.5em;color: darkred">. ^ $ * + ? { } [ ] \ | ( )</span>
      </code></pre>
      <dt>All characters which are <span class="note">not metacharacters</span> are matched literally.</dt>
    </dl>
  </section>
  <section><h3>metacharacters - example</h3>
    <pre><code rel="Python3" class="python">
      import re

      phone_numbers = ['+359 88 7123 456', '+359 88 7123456' ]

      # match numbers with format: +359 YY YXXX XXX
      regex = r'\+359\s\d{2}\s\d{4}\s\d{3}'

      for number in phone_numners:
        if re.match(regex,number):
          print("{} is a valid number format".format(number))
        else:
          print("{} is NOT IN A VALID FORMAT".format(number))
    </code></pre>
    <pre><code rel="Output" class="bash" data-noescape>
      +359 88 7123 456 is a valid number format
      +359 88 7123456 is NOT IN A VALID FORMAT
    </code></pre>
  </section>
</section>

<section data-min="20"><h1>Using regexes in Python - the <code><a href="https://docs.python.org/3/library/re.html">re</a></code> module</h1></section>
<section><h2>Using regexes in Python - the <code><a href="https://docs.python.org/3/library/re.html">re</a></code> module</h2>
  <section><h3>Overview</h3>
    <dl class="fa">
      <dt>The built-in <code><a href="https://docs.python.org/3/library/re.html">re</a></code> module in Python provides regular expression matching operations similar to those found in Perl.</dt>
      <dt>Regular expressions are compiled into <a href="https://docs.python.org/3/library/re.html#re-objects">Regular Expression Object</a>, which have methods for various operations such as searching for pattern matches or performing string substitutions.</dt>
      <dt>REs in Python are handled as strings because regular expressions aren’t part of the core Python language, and no special syntax was created for expressing them.</dt>
    </dl>
  </section>
  <section><h3>How to write regex</h3>
    <dl class="fa">
      <dt>Regex in Python are written as string, which can be passed to re.compile() method or directly to other matching methods, like re.search(), re.match()</dt>
      <dt>We can use any string literals, including the <a href="">row string</a> syntax.</dt>
    </dl>
  </section>
  <section><h3>Matching backslash</h3>
    <dl class="fa">
      <dt>The <span class="note">raw string</span> syntax is most concise when we need to match a backslash</dt>
      <dt>The <a href="https://docs.python.org/2/reference/lexical_analysis.html#index-17">raw string</a> @docs:</dt>
      <dd>When an 'r' or 'R' prefix is present, a character following a backslash is included in the string without change, and all backslashes are left in the string</dd>
      <dd>a raw string cannot end in a single backslash</dd>
    </dl>
    <pre><code rel="Python" class="python">
      print(len(r'\n')) #2
      print(len(r'\')) #SyntaxError
    </code></pre>
  </section>
  <section><h3>Matching backslash</h3>
    <pre><code rel="Python" class="python">
      import re

      text = '\\stop'
      re1 = '\\\\stop'
      re2 = '\\stop'
      re3 = r'\\stop'


      if re.match(re1, text):
        print("re1 matched!")

      if re.match(re2, text):
        # would not match, as '\' is a special character in regex and should be escaped, as well
        print("re2 matched!")

      if re.match(re3, text):
        print("re3 matched!")
    </code></pre>
  </section>
  <section><h3>the <code><a href="https://docs.python.org/3/library/re.html#re.compile">re.compile()</a></code> method</h3>
    <dl class="fa">
      <dt>Compiles a regular expression pattern into a regular expression object, which can be used for matching using its methods for matching and search</dt>
    </dl>
    <pre><code rel="Python" class="python">
      import re

      text = "ABRACADABRA"

      regex = re.compile(r'aca', re.I)

      if regex.search(text):
        print('Match')
    </code></pre>
  </section>
</section>


<section data-min="20"><h1>Regex Match Methods</h1></section>
<section><h2>Regex Match Methods</h2>
  <section><h3><a href="https://docs.python.org/3/library/re.html#re.regex.search">regex.search(string[, start[, end]]))</a></h3>
    <dl class="fa">
      <dt>Scan through string looking for the  where this regular expression produces a match.</dt>
      <dt>If match produced => returns a corresponding <a href="https://docs.python.org/3/library/re.html#match-objects">match object</a></dt>
      <dt>If string does not matches the pattern => return <span class="note">None</span></dt>
      <dt>optional parameters:</dt>
      <dd><i>start</i> - the index where the search should start</dd>
      <dd><i>end</i> - the index where the search should ends</dd>
    </dl>
  </section>
  <section><h3><a href="https://docs.python.org/3/library/re.html#re.regex.search">regex.search(string[, start[, end]]))</a> - example</h3>
    <pre><code rel="Python" class="python">
      import re

      text = "123abc456"
      rx = re.compile('abc')

      res = rx.search(text) # will match
      res = rx.search(text,3) # will match, 'a' is on index 3 in text
      res = rx.search(text,4) # would NOT match
    </code></pre>
  </section>
  <section><h3><a href="https://docs.python.org/3/library/re.html#re.regex.match">regex.match(string[, start[, end]])</a></h3>
    <dl class="fa">
      <dt>Matches only <span class="note">on the beginning of the string</span></dt>
      <dt>If you want to locate a match anywhere in string, use search() instead</dt>
      <dt>Reference: <a href="https://docs.python.org/3/library/re.html#search-vs-match">search-vs-match @python docs</a></dt>
      <!-- <dt>For the rest - acts like regex.search() method</dt> -->
    </dl>
  </section>
  <section><h3><a href="https://docs.python.org/3/library/re.html#re.regex.match">regex.match(string[, start[, end]])</a> - example</h3>
    <pre><code rel="Python" class="python">
      text = "123abc456"
      rx = re.compile('abc')

      res = rx.match(text)

      res = rx.match(text) # will NOT match, 'abc' is not in the beginning
      res = rx.match(text,3) # will match, as matching starts from index 3
    </code></pre>
  </section>
  <section><h3><a href="https://docs.python.org/3/library/re.html#re.regex.findall">regex.findall(string[, pos[, endpos]])</a></h3>
    <dl class="fa">
      <dt>Returns <span class="note"> a list of strings</span> containing all non-overlapping matches of regex in the string</dt>
      <dt>The string is scanned left-to-right, and matches are returned in the order found</dt>
    </dl>
  </section>
  <section><h3><a href="https://docs.python.org/3/library/re.html#re.regex.findall">regex.findall(string[, pos[, endpos]])</a> -example</h3>
    <pre><code rel="Python" class="python">
      text = "123abc456abcabc"
      rx = re.compile('abc')

      res = rx.findall(text) # ['abc', 'abc', 'abc']
      res = rx.findall(\dtext) # ['3abc', '6abc']
    </code></pre>
  </section>
  <section><h3>Other Matching Methods</h3>
    <dl class="fa">
      <dt><a href="https://docs.python.org/3/library/re.html#re.regex.finditer">regex.finditer(string[, pos[, endpos]])</a></dt>
      <dt><a href="https://docs.python.org/3/library/re.html#re.regex.fullmatch">regex.fullmatch(string[, pos[, endpos]])</a></dt>
      <dt><a href="https://docs.python.org/3/library/re.html#re.regex.sub">regex.sub(repl, string, count=0)</a></dt>
      <dt><a href="https://docs.python.org/3/library/re.html#re.regex.subn">regex.subn(repl, string, count=0)</a></dt>
    </dl>
  </section>
  <section><h3>re module-level matching methods</h3>
    <dl class="fa">
      <dt>The methods described above, was methods of an Regular Expression Objects</dt>
      <dt>Python has the same methods defined for re module, like:</dt>
      <dd><a href="https://docs.python.org/3/library/re.html#re.search">re.search(pattern, string, flags=0)</a></dd>
      <dd>and so on...</dd>
      <dt>The difference is that we must pass the pattern string as first argument, and optional flags at the end.</dt>
    </dl>
  </section>
  <section><h3>When to use Regex Match Methods?</h3>
    <dl class="fa">
      <dt>The modlule-level match functions compile the given regex string, and keep it in its cache. So future calls using the same RE won’t need to parse the pattern again</dt>
      <dt>But when you use the function in a loop, the function itself will be needlessly called, that's why in loops, it is better to use the precompiled regex.</dt>
    </dl>
  </section>
</section>


<section data-min="10"><h1><a href="https://docs.python.org/3/library/re.html#match-objects">Match Objects</a></h1></section>
<section><h2>The Match Object</h2>
  <section><h3>Overview</h3>
    <dl class="fa">
      <dt>match() and search() methods returns a <a href="https://docs.python.org/3/library/re.html#match-objects">Match Object</a></dt>
      <dt>It always have a boolean value of True</dt>
      <dt>It contains useful information about the matched strings.</dt>
    </dl>
  </section>
  <section><h3><a href="https://docs.python.org/3/library/re.html#match-objects">Match Object</a> Methods</h3>
    <table style="width: 110%">
      <tr><th>Method/Attribute</th><th>Purpose</th></tr>
      <tr><td>group()</td><td>Return the string matched by the RE</td></tr>
      <tr><td>groups()</td><td>Return a tuple containing all the subgroups of the match</td></tr>
      <tr><td>start()</td><td>Return the starting position of the match</td></tr>
      <tr><td>end()</td><td>Return the ending position of the match</td></tr>
      <tr><td>span()</td><td>Return a tuple containing the (start, end) positions of the match</td></tr>
    </table>
    <p>More methods: <a href="https://docs.python.org/3/library/re.html#match-objects">Match Object</a></p>
  </section>
  <section><h3><a href="https://docs.python.org/3/library/re.html#match-objects">Match Object</a> Methods - example</h3>
    <pre><code rel="Python" class="python">
      text = "123abc456abc"
      rx = re.compile('(\d+)(abc)')

      res = rx.match(text)
      if res:
        print("res.group():", res.group()) #123abc
        print("res.groups():", res.groups()) #('123', 'abc')
      else:
        print("No match!")
    </code></pre>
    <p class="note">We will discuss capturing groups on next slides</p>
  </section>
</section>


<section data-min="20"><h1>Regex Syntax</h1></section>
<section><h2>Regex Syntax</h2>
  <section><h3>Special Characters</h3>
    <p>Only next characters has special meaning in Regex:</p>
    <code class="note">^ $ \ . * + ? ( ) [ ] { } |</code>
    <p>They can be combined with ordinary characters to change their meaning too</p>
    <p>If we want to match <b>literally</b> a special character we have to escape it with backslash <code>'\'</code></p>
  </section>
  <section><h3>Matching Special Characters - example</h3>
    <pre><code rel="Python" class="python">
      import re

      text = "try to match: 2+3"
      rx = re.compile('2\+3')

      res = rx.search(text)
      if res:
        print( res.group())
    </code></pre>
  </section>
</section>

<section data-min="5"><h1>Quantifiers</h1></section>
<section><h2>Quantifiers</h2>
  <section><h3>Overview</h3>
    <table style="font-size: .9em">
      <tr><th>Quantifier</th><th>Description</th></tr>
      <tr><td><i>r</i> <b class="note">*</b></td><td><i>r</i> match <b>0</b> or <b>more times</b></td></tr>
      <tr><td><i>r</i> <b class="note">+</b></td><td><i>r</i> match <b>1</b> or <b>more times</b></td></tr>
      <tr><td><i>r</i> <b class="note">?</b></td><td><i>r</i> match <b>0</b> or <b>1</b>time</td></tr>
      <tr><td><i>r</i> <b class="note">{n}</b></td><td><i>r</i> match <b>exactly <i>n</i> times</b></td></tr>
      <tr><td><i>r</i> <b class="note">{n,m}</b></td><td><i>r</i> match between <b>n</b> and <b>m</b> times (n, m are positive)</td></tr>
    </table>
    <p class="note"><code>r</code> can be any regex!</p>
  </section>
  <section><h3>Quantifiers (greedy and non-greedy match)</h3>
    <dl class="fa">
      <dt>The quantifiers are <span class="note">greedy</span>, meaning they will match the maximum part of the string they can:</dt>
      <pre><code rel="Python" class="python">
        matched = re.search(r'a.*a','ala bala' );
        print(matched)
        # match='ala bala', but not 'ala'
      </code></pre>
    </dl>
  </section>
  <section><h3>Quantifiers (greedy and non-greedy match)</h3>
    <dl class="fa">
      <dt>We can make them <span class="note">non-greedy</span>, if we suffix them with '<code class="note">?</code>'</dt>
      <pre><code rel="Python" class="python">
        matched = re.search(r'a.*?a','ala bala' );
        print(matched)
        #match='ala'
      </code></pre>
    </dl>
  </section>
  <section><h3>'*'quantifier - example</h3>
    <pre><code rel="Python" class="python">
      import re

      string = 'ala bala'

      matched = re.findall(r'a.*a',string ) # greedy
      print(matched)
      #OUTPUT: ['ala bala']

      matched = re.findall(r'a.*?a',string ) # non-greedy
      print(matched)
      #OUTPUT: ['ala', 'ala']

      matched = re.findall(r'.*?',string ) # non-gready
      print(matched)
      #OUTPUT: ['', '', '', '', '', '', '', '', ''
    </code></pre>
  </section>
  <section><h3>{n,m} quantifier - example</h3>
    <pre><code rel="Python" class="python">
      import re

      matched = re.findall(r'\d{2,4}','123456789' ) # gready
      print(matched)
      # OUTPUT: ['1234', '5678']

      matched = re.findall(r'\d{2,4}?','123456789' ) # non-gready
      print(matched)
      #OUTPUT: ['12', '34', '56', '78']
    </code></pre>
  </section>
</section>



<section data-min="5"><h1>Character Sets</h1></section>
<section><h2>Character Sets</h2>
  <section><h3>Overview</h3>
    <dl class="fa">
        <dt>The square brackets are used to define a character set. Like: <code><b>[</b>abc<b>]</b></code> (will match 'a' or 'b' or 'c').</dt>
        <dt class="note">The character set itself match only one symbol!</dt>
        <dt>Symbols inside brackets are the elements of set.</dt>
        <dt>Special characters lose their special meaning inside sets</dt>
        <dt>The hyphen (<code>-</code>), when it is between 2 symbols, has special meaning inside the character class  - it defines a range. Like: <code>[0-9]</code>. If it is in the end, it is considered as a hyphen.</dt>
    </dl>
  </section>
  <section><h3>Character Sets Description</h3>
    <table>
      <tr><th>Character set</th><th>Description</th></tr>
      <tr><td><code class="note">[abc]</code></td><td>Match any one of the symbols listed ('a' or 'b' or 'c')</td></tr>
      <tr><td><code class="note">[a-z]</code></td><td>Match any symbol, from 'a' till 'z' (i.e. any lower Latin letter)</td></tr>
      <tr><td><code class="note">[^abc]</code></td><td>Match any symbol, except 'a or 'b' or 'c' (i.e. the <code><b>^</b></code> negates the characters in the set)</td></tr>
    </table>
  </section>
  <section><h3>Character Sets examples</h3>
    <pre><code rel="Python" class="python">
      import re

      # match any one of the vocals
      matched = re.findall(r'[aeiouy]','astroid' );
      print(matched)
      #OUTPUT: ['a', 'o', 'i']

      # match any consecutive vocals - one or more times
      matched = re.findall(r'[aeiouy]+','astroid' );
      print(matched)
      #OUTPUT: ['a', 'oi']

      # match bg mobile phone numbers
      matched = re.findall('\+3598[7-9][0-9]{7}', '+359888123456');
      print(matched)
      #OUTPUT: ['+359888123456']

      # match digit or hyphen:
      matched = re.findall('[1-5-]', '12-34');
      print(matched)
      #OUTPUT: ['1', '2', '-', '3', '4']
    </code></pre>
  </section>
  <section><h3>Character Sets Negation - examples</h3>
    <pre><code rel="Python" class="python">
      import re

      # match any non-vocal:
      matched = re.findall(r'[^aeiouy]','astroid' );
      print(matched)
      #OUTPUT: ['s', 't', 'r', 'd']
    </code></pre>
  </section>
</section>


<section data-min="5"><h1>Character classes</h1></section>
<section><h2>Character classes</h2>
  <section><h3>Character classes</h3>
    <dl class="fa">
        <dt>Character classes can be regarded as shorthands for some of the most used  character sets.</dt>
        <dt>In python3 they work only on any Unicode symbols.</dt>
        <dd>You can use the <a href="https://docs.python.org/3/library/re.html#re.ASCII">re.ASCII/(?a)</a>  flag to specify that you want only ASCII symbols to be matched.</dd>
    </dl>
  </section>
  <section><h3>Character classes</h3>
    <table style="font-size: .8em">
      <tr><th>Char class</th><th>Description</th></tr>
      <tr><td><code class="note">.</code></td><td>Match <span class="note">any</span> character, except newline/line terminator. You can use the <a href="https://docs.python.org/3/library/re.html#re.S">re.DOTALL/(?s)</a> to match the new line, as well</td></tr>
      <tr><td><code class="note">\w</code></td><td>Matches Unicode word characters; this includes most characters that can be part of a word in any language, as well as numbers and the underscore.<br>If the ASCII flag is used, only [a-zA-Z0-9_] is matched </td></tr>
      <tr><td><code class="note">\d</code></td><td>Matches any Unicode decimal digit, which includes [0-9], and also many other digit characters<br>If the ASCII flag is used, only [0-9] is matched</td></tr>
      <tr><td><code class="note">\s</code></td><td>Matches any Unicode whitespace characters (which includes [ \t\n\r\f\v], and also many other characters,</td></tr>
    </table>
  </section>
  <section><h3>Character classes example</h3>
    <pre><code rel="Python" class="python">
      import re

      # match bg mobile phone numbers
      matched = re.findall('\+3598[7-9]\d{7}', '+359888123456');
      print(matched)
      #OUTPUT: ['+359888123456']
    </code></pre>
  </section>
  <section><h3>Character classes example</h3>
    <pre><code rel="Python" class="python">
      import re

      strings = ['petrov42','42petrov','ivan_pterov']
      rx = re.compile('[a-z]\w+')

      for string in strings:
        matched = rx.search(string);
        print("{} matched in {}".format(matched.group(),string) )
      #OUTPUT:
      #petrov42 matched in petrov42
      #petrov matched in 42petrov
      #ivan_pterov matched in ivan_pterov
    </code></pre>
  </section>
  <section><h3>Character classes example</h3>
  	<pre><code rel="Python" class="python">
  		string = """line1
  		line2
  		line3 line4"""

  		matched = re.findall('line\d\s', string);
  		print(matched)

  		#OUTPUT: ['line1\n', 'line2\n', 'line3 ']
  	</code></pre>
  </section>
</section>


<section data-min="5"><h1>Modifiers/Flags</h1></section>
<section><h2>Modifiers/Flags</h2>
  <section><h3>Modifiers/Flags</h3>
    <dl class="fa">
      <dt>Flags reflects how the regular expression is executed.</dt>
      <dt>They are available in the re module with a long name such as re.IGNORECASE or with a short, one-letter form such as re.I.</dt>
      <dt>Multiple flags can be specified by bitwise OR-ing them. For example <code>re.I|re.M</code> sets both the I and M flags.</dt>
      <dt>These flags are set by passing the <i>flags</i> argument to the re.compile() method</dt>
      <dt>Flags can be also set in the regular expression itself, using (?aiLmsux) syntax at the beginning of the regex</dt>
    </dl>
  </section>
  <section><h3>Modifiers/Flags list</h3>
    <table >
      <tr><th>In reges</th><th>As param</th><th>Description</th></tr>
      <tr><td>(?i)</td><td>re.I</td><td>case-<b>i</b>nsensitive matching</td></tr>
      <tr><td>(?m)</td><td>re.M</td><td><b>m</b>ultiline matching</td></tr>
      <tr><td>(?s)</td><td>re.S</td><td>Make the '<b>.</b>' to match any character at all, including a newline</td></tr>
      <tr><td>(?x)</td><td>re.X</td><td>Allows to write readable regexes by using spaces and comments('#') in the regex. More on: <a href="https://docs.python.org/3/library/re.html#re.X">re.X</a></td></tr>
    </table>
  </section>
  <section><h3>Modifiers/Flags example</h3>
    <pre><code rel="Python" class="python">
      import re

      text = """123
      ABC
      456"""
      rx = re.compile('(?is)123.abc')

      res = rx.search(text)
      if res:
        print(res.group(0))
      else:
        print("No match!")
    </code></pre>
  </section>
</section>


<section data-min="5"><h1>Anchors and Boundaries</h1></section>
<section><h2>Anchors and Boundaries</h2>
  <section><h3>Overview</h3>
    <dl class="fa">
      <dt>They specify a <b>position</b> in the string where a match should occurs.</dt>
      <dt>They are zero-width, i.e.when matched they do NOT consume characters from the string.</dt>
    </dl>
  </section>
  <section><h3>Anchors and Boundaries</h3>
    <table style="font-size: .9em">
      <tr><th>Anchor</th><th>Description</th></tr>
      <tr><td class="note">^</td><td>Matches the <span class="note">beginning</span> of the string (or the line, if <b>m</b> flag is used)</td></tr>
      <tr><td class="note">$</td><td>Matches the <span class="note">end</span> of the string (or the line, if <b>m</b> flag is used)</td></tr>
      <tr><td class="note">\b</td><td>Matches on word boundaries, i.e. between <i>word</i>(\w) and <i>non-word</i>(\W) characters.<br>Note that the <b>start</b> and <b>end</b> of string are considered as non-word characters.</td></tr>
      <tr><td class="note">\Z</td><td>Matches only at the end of the string.</td></tr>
    </table>
  </section>
  <section><h3>Anchors and Boundaries example</h3>
    <pre><code rel="Python" class="python">
      import re

      strings = [
        '',
        'a',
        '@',
        '@a',
        'aa',
        'a!',
        'a,a',
      ]
      rx = re.compile(r'\b');

      for string in strings:
        res = rx.findall(string)
        print("{} word bounders counted in {}".format(len(res), string))
      #OUTPUT
      #0 word bounders counted in
      #2 word bounders counted in a
      #0 word bounders counted in @
      #2 word bounders counted in @a
      #2 word bounders counted in aa
      #2 word bounders counted in a!
      #4 word bounders counted in a,a
    </code></pre>
  </section>
  <section><h3>Anchors and Boundaries example</h3>
    <pre><code rel="Python" class="python">
    	strings = [
    	  'ana',
    	  'ana bel',
    	]
    	rx = re.compile(r'^a\w+a$');

    	for string in strings:
    	  res = rx.findall(string)
    	  print("{} matches in {}".format(len(res), string))
    	#OUTPUT:
    	#1 matches in ana
    	#0 matches in ana bel
    </code></pre>
  </section>
  <!-- <section><h3>Anchors and Boundaries example</h3>
    <pre><code rel="Python" class="python">
      var re = /\b[\w-]+\b/gi;
      var strings = [
        'one two three four, five, six. Seven!',
        'one-two,three!',
      ];
      strings.forEach(str=>{
        var res = str.match(re);
        res && console.log(`${res.length} matches in '${str}'`)
      });
      // 7 matches in 'one two three four, five, six. Seven!'
      // 2 matches in 'one-two,three!'
    </code></pre>
  </section> -->
</section>


<section data-min="5"><h1>Alternation</h1></section>
<section><h2>Alternation</h2>
  <section><h3>Alternation</h3>
    <dl class="fa">
      <dt>With alternation we can match one <span class="note">or</span> another regexp!</dt>
    </dl>
    <table>
      <tr><th>Alternation</th><th>Description</th></tr>
      <tr><td>r1<span class="note">|</span>r2</td><td>Matches if r1 OR r2 is matched</td></tr>
    </table>
  </section>
  <!-- <section><h3>Alternation example</h3>
    <pre><code rel="Python" class="python">
      // NB: this is not example of good practice for grouping regex. Why? => check next slides
      var re = /\b(straw|rasp)?berries/;
      var strings = [
        'Icecream with strawberries? Yes!',
        'Icecream with blueberries? No!',
        'Icecream with raspberries? Yes!',
        'Icecream with berries? Yes!',
      ]

      strings.forEach(str=> str.match(re) ?
        console.log(`${str} YES! YES!`) : console.log(`${str} NO! NO!`)
      )
      // Icecream with strawberries? Yes! YES! YES!
      // Icecream with blueberries? No! NO! NO!
      // Icecream with raspberries? Yes! YES! YES!
      // Icecream with berries? Yes! YES! YES!
    </code></pre>
  </section> -->
</section>


<section data-min="5"><h1>Grouping and capturing</h1></section>
<section><h2>Grouping and capturing</h2>
  <section><h3>Grouping and back references</h3>
    <dl class="fa" style="font-size: .8em">
      <dt>Brackets: <span class="note">(</span> and <span class="note">)</span>, play a dual role in regex!</dt>
      <dt>They can be used for grouping regexes.Like: </dt>
      <dd><code><b>/(r1|r2)r3/</b></code> => match <code><b>r1r3</b></code> OR <code><b>r2r3</b></code>, but not <code><b>r1r2r3</b></code></dd>
      <dt>Or they can be used to <span class="note">capture</span> (remember) the matched part of the string. Like: </dt>
      <dd><code><b>/(r1)r2/</b></code> => match <code><b>r1r2</b></code> and capture the part of the string that matched <code><b>r1</b></code></dd>
      <dt>If you just want to <span class="note">group regexes, without capturing the match</span>, you should explicitly state that by: </dt>
      <dd><code>(<span class="note">?:</span>r1|r2)</code> => match <code><b>r1</b></code> or <code><b>r2</b></code> but <span class="note"><b>do not capture</b></span> the match</dd>
      <dt class="note">NB! Capturing is slow and memory consuming! If you need the parenthesis just for grouping- always use the <b>?:</b> prefix.</dt class="note">
    </dl>
  </section>
  <section><h3>Capturing - example</h3>
  	<pre><code rel="Python" class="python">
  		import re

  		user = 'Ivan Ivanov: +359 887123456'

  		rx = re.compile("""(?x)
  		  ([A-Z]\w+)\s+   # capture first name
  		  ([A-Z]\w+):\s+  # capture sur name
  		  \+(\d{3})\s     # capture country code
  		  (\d{6,8})       # capture number
  		""")

  		res = rx.search(user)
  		if res:
  		  i = 0
  		  for t in res.groups():
  		    print("Capture {}: {}".format(i,t))
  		    i+=1

  		#OUTPUT:
  		#Capture 0: Ivan
  		#Capture 1: Ivanov
  		#Capture 2: 359
  		#Capture 3: 88712345
  	</code></pre>
  </section>
  <section><h3>Grouping regexes example</h3>
    <pre><code rel="Python" style="font-size: .8em;">
      import re

      strings = [
        'Icecream with strawberries?',
        'Icecream with blueberries?',
        'Icecream with raspberries?',
        'Icecream with strawraspberries?',
        'Icecream with berries?',
      ]
      rx = re.compile(r'\b(?:straw|rasp)?berries');

      for string in strings:
        res = rx.search(string)
        if res:
          print('{} YES!'.format(string))
        else:
          print('{} NO!'.format(string))
      #OUTPUT:
      #Icecream with strawberries? YES!
      #Icecream with blueberries? NO!
      #Icecream with raspberries? YES!
      #Icecream with strawraspberries? NO!
      #Icecream with berries? YES!
    </code></pre>
  </section>
</section>
<!--   <section><h3>Assertions</h3>
    <p>Gives the possibility to match a regex only if it is followed or not by something. I.e. we can make lookahead!</p>
    <p class="advanced"></p>
  </section> -->

<section data-min="5"><h1>Resources</h1></section>
<section><h2>Videos</h2>
  <section>
    <p>Reg(exp){2}lained/: Demystifying Regular Expressions by Lea Verou</p>
    <iframe width="767" height="431" src="https://www.youtube.com/embed/EkluES9Rvak" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
  </section>
</section>

<section><h3>Online Regex Testers for Python</h3>
  <dl class="fa">
    <dt><a href="https://regex101.com/">regex101.com - Online regex tester and debugger: PHP, PCRE, Python, Golang and</a></dt>
  </dl>
</section>

<section id="hw"><h1>Exercises</h1></section>
<section><h2>Online Chalanges</h2>
  <section>
    <dl class="fa">
      <dt><a href="https://www.hackerrank.com/domains/regex">Practice Regex @Hackerrank</a></dt>
    </dl>
  </section>
</section>

<!--
<section><h3>Submission</h3>
  <dl class="fa">
    <dt>Please, prefix your filenames/archive with your name initials, before sending.</dt>
    <dd>For instance: <b>iep_task1.py</b> or <b>iep_tasks.rar</b></dd>
    <dt>Send files to <a href="mailto:progressbg.python.course@gmail.com?Subject=HW: regexes">progressbg.python.course@gmail.com</a></dt>
  </dl>
</section> -->



<section class="disclaimer" data-background="/ProgressBG-Python-UniCredit-Slides/outfit/images/for_slides/the_end_on_sand.jpg">
   <p>These slides are based on</p>
   <p>customised version of </p>
   <p><a href="http://hakim.se/">Hakimel</a>'s <a href="http://lab.hakim.se/reveal-js">reveal.js</a></p>
   <p>framework</p>
</section>
<!--
########################################################
##################### SLIDES END   #####################
########################################################
-->
    </div>
  </div>
  <!-- Custom processing -->
  <script src="/ProgressBG-Python-UniCredit-Slides/outfit/js/slides.js"></script>
  <!-- external scripts -->
  <script src="/ProgressBG-Python-UniCredit-Slides/lib/reveal.js/lib/js/head.min.js"></script>
  <script src="/ProgressBG-Python-UniCredit-Slides/lib/reveal.js/js/reveal.js"></script>
   <!-- init reveal -->
  <script>
    // Full list of configuration options available at:
    // https://github.com/hakimel/reveal.js#configuration
    var highlightjsTabSize = '  ';
    Reveal.initialize({
      controls: true,
      progress: true,
      slideNumber: 'c/t',
      keyboard: true,
      history: true,
      center: true,
      width: 1024,
      height: 850,
      // Bounds for smallest/largest possible scale to apply to content
      // minScale: .5,
      maxScale: 1,
      // slide transition
      transition: 'concave', // none/fade/slide/convex/concave/zoom
      // Factor of the display size that should remain empty around the content
      margin: 0.1,
      // shift+maous click to zoom in/out element
      zoomKey: 'ctrl',
      // theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
      // transition: Reveal.getQueryHash().transition || 'default'
      // Optional reveal.js plugins
      dependencies: [
        { src: '/ProgressBG-Python-UniCredit-Slides/lib/reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
        { src: '/ProgressBG-Python-UniCredit-Slides/lib/reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
        { src: '/ProgressBG-Python-UniCredit-Slides/lib/reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
        { src: '/ProgressBG-Python-UniCredit-Slides/lib/reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.configure({tabReplace: highlightjsTabSize}); hljs.initHighlightingOnLoad(); } },
        { src: '/ProgressBG-Python-UniCredit-Slides/lib/reveal.js/plugin/zoom-js/zoom.js', async: true },
        { src: '/ProgressBG-Python-UniCredit-Slides/lib/reveal.js/plugin/notes/notes.js', async: true }
      ]
    });
  </script>
</body>
</html>
