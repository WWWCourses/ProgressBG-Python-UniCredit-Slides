<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>regexes</title>
	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
	<!-- css & themes include -->
	<link rel="stylesheet" href="/ProgressBG-Python-UniCredit-Slides/lib/reveal.js/css/reveal.css">
	<link rel="stylesheet" href="/ProgressBG-Python-UniCredit-Slides/outfit/css/themes/light.css" id="theme">
	<!-- Printing and PDF exports -->
	<script>
		var link = document.createElement( 'link' );
		link.rel = 'stylesheet';
		link.type = 'text/css';
		link.href = window.location.search.match( /print-pdf/gi ) ? '/ProgressBG-Python-UniCredit-Slides/lib/reveal.js/css/print/pdf.css' : '/ProgressBG-Python-UniCredit-Slides/lib/reveal.js/css/print/paper.css';
		document.getElementsByTagName( 'head' )[0].appendChild( link );
	</script>
	<!--[if lt IE 9]>
	<script src="lib/js/html5shiv.js"></script>
	<![endif]-->
	<!-- CUSTOM -->
	<base target="_blank">
</head>
<body>
	<div class="reveal default center" data-transition-speed="default" data-background-transition="default">
		<div class="top_links">
			<a class="home_link" href="/ProgressBG-Python-UniCredit-Slides/pages/agenda/agenda.html#regexes" target="_top"><i class="fa fa-home"></i></a>
			<span class="help_link" href="#"><i class="fa fa-question"></i></span>
			<div class="help_text">
				<div class="note">Keyboard shortcuts:</div>
				<div><span>N/Спейс</span><span>Next Slide</span></div>
				<div><span>P</span><span>Previous Slide</span></div>
				<div><span>O</span><span>Slides Overview</span></div>
				<div><span>ctrl+left click</span><span>Zoom Element</span></div>
				<div class="print-howto"><br>If you want print version => add '<code>?print-pdf</code>' <br> at the end of slides URL (remove '#' fragment) and then print. <br>
				Like: https://wwwcourses.github.io/...CourseIntro.html?print-pdf </div>
			</div>
		</div>
		<div class="footer theme_switch">
			<a href="#" onclick="document.getElementById('theme').setAttribute('href','/ProgressBG-Python-UniCredit-Slides/outfit/css/themes/dark.css'); return false;">Dark</a>
			<a href="#" onclick="document.getElementById('theme').setAttribute('href','/ProgressBG-Python-UniCredit-Slides/outfit/css/themes/light.css'); return false;">Light</a>
			<a href="#" onclick="document.getElementById('theme').setAttribute('href','/ProgressBG-Python-UniCredit-Slides/outfit/css/themes/projector.css'); return false;">Projector</a>
		</div>
		<div class="slides">
<!--
########################################################
##################### SLIDES START #####################
########################################################
-->
<section data-min-total="80"><h1>Regular Expressions in Python</h1></section>
<section data-transition="zoom">
	<!-- linkedin badge -->
	<!--<script type="text/javascript" src="https://platform.linkedin.com/badges/js/profile.js" async defer></script>-->
	<section class="copyright" data-transition="zoom">
		<div class="note">
			<p>Created for</p>
		</div>
		<div class="company">
			<a href="http://progressbg.net/програмиране-с-python-2/">
			<img style="height:80%" src="/ProgressBG-Python-UniCredit-Slides/outfit/images/logos/ProgressBG_logo_529_127.png">
			</a>
		</div>
		<div class="author">
			<span class="note">Iva E. Popova, 2016-2022,</span>
			<a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"></a>
		</div>
	</section>
	<section class="copyright" data-transition="zoom" style="margin-top: -2em;">
		<div class="company">
			 <div class="LI-profile-badge"  data-version="v1" data-size="large" data-locale="en_US" data-type="vertical" data-theme="dark" data-vanity="ivapopova"><a class="LI-simple-link" href='https://bg.linkedin.com/in/ivapopova?trk=profile-badge'>Iva E. Popova on LinkedIn</a></div>
		</div>
	</section>
</section>

<section data-min="20"><h1>Regular Expressions Basis</h1></section>
<section><h2>Regular Expressions Basis</h2>
	<section><h3>Overview</h3>
		<dl class="fa">
			<dt>Regular Expression synonyms:</dt>
			<dd data-tooltip="/\breg(?:ular\s*)?exp?(?:ression)?\b/i">Regex, RegEx, RegExp</dd>
			<dt>Regular Expression is a <span class="note">string pattern</span>, which can match or not other stings</dt>
			<dt>You can think of it a as a kind of search mechanism.</dt>
		</dl>
	</section>
	<section>
		<pre><code rel="Python3" class="python">
			import re

			# the string to search with regex:
			user_email = "prefix@domain.com"

			# the regex to find if the userEmail contains '@' symbol:
			regex = re.compile(r'@')

			# do the match test:
			if regex.search(user_email):
				print("Match!")
			else:
				print("No match!")
		</code></pre>
	</section>
	<section><h3>the language</h3>
		<dl class="fa">
			<dt>You can think of Regular Expressions as a separate language, with its own rules and specs.</dt>
			<dt>In fact, the Regular Expressions are coming from the <span class="note">regular language</span> defined by <a href="https://en.wikipedia.org/wiki/Stephen_Cole_Kleene">Kleene</a> in the early 1950s</dt>
			<dt>Nowadays, almost all programming languages implements the concept of Regex.</dt>
		</dl>
	</section>
	<section>
		<dl class="fa">
			<dt>A regex grammar includes 2 types of symbols:</dt>
			<dd><span class="note">Regular symbols</span>: they are matched literally on the matching string</dd>
			<dd><span class="note">Meta-characters</span>: they have special meaning and gives the power of regex</dd>
			<pre><code rel="complete list of regex metacharacters" class="python" data-noescape>

				<span style="font-size: 1.5em;line-height:1.5em;color: darkred">. ^ $ * + ? { } [ ] \ | ( )</span>
			</code></pre>
			<dt>All characters which are <span class="note">not metacharacters</span> are matched literally.</dt>
		</dl>
	</section>
	<section><h3>metacharacters - example</h3>
		<pre><code rel="Python3" class="python">
			import re

			phone_numbers = ['+359 88 7123 456', '+359 88 7123456' ]

			# match numbers with format: +359 YY YXXX XXX
			regex = r'\+359\s\d{2}\s\d{4}\s\d{3}'

			for number in phone_numners:
				if re.match(regex,number):
					print("{} is a valid number format".format(number))
				else:
					print("{} is NOT IN A VALID FORMAT".format(number))
		</code></pre>
		<pre><code rel="Output" class="bash" data-noescape>
			+359 88 7123 456 is a valid number format
			+359 88 7123456 is NOT IN A VALID FORMAT
		</code></pre>
	</section>
</section>

<section data-min="20"><h1>Using regexes in Python - the <code><a href="https://docs.python.org/3/library/re.html">re</a></code> module</h1></section>
<section><h2>Using regexes in Python - the <code><a href="https://docs.python.org/3/library/re.html">re</a></code> module</h2>
	<section><h3>Overview</h3>
		<dl class="fa">
			<dt>The built-in <code><a href="https://docs.python.org/3/library/re.html">re</a></code> module in Python provides regular expression matching operations similar to those found in Perl.</dt>
			<dt>Regular expressions are compiled into <a href="https://docs.python.org/3/library/re.html#re-objects">Regular Expression Object</a>, which have methods for various operations such as searching for pattern matches or performing string substitutions.</dt>
			<dt>REs in Python are handled as strings because regular expressions aren’t part of the core Python language, and no special syntax was created for expressing them.</dt>
		</dl>
	</section>
	<section><h3>How to write regex</h3>
		<dl class="fa">
			<dt>Regex in Python are written as string, which can be passed to re.compile() method or directly to other matching methods, like re.search(), re.match()</dt>
			<dt>We can use any string literals, including the <a href="">row string</a> syntax.</dt>
		</dl>
	</section>
	<section><h3>Matching backslash</h3>
		<dl class="fa">
			<dt>The <span class="note">raw string</span> syntax is most concise when we need to match a backslash</dt>
			<dt>The <a href="https://docs.python.org/2/reference/lexical_analysis.html#index-17">raw string</a> @docs:</dt>
			<dd>When an 'r' or 'R' prefix is present, a character following a backslash is included in the string without change, and all backslashes are left in the string</dd>
			<dd>a raw string cannot end in a single backslash</dd>
		</dl>
		<pre><code rel="Python" class="python">
			print(len(r'\n')) #2
			print(len(r'\')) #SyntaxError
		</code></pre>
	</section>
	<section><h3>Matching backslash</h3>
		<pre><code rel="Python" class="python">
			import re

			text = '\\stop'
			re1 = '\\\\stop'
			re2 = '\\stop'
			re3 = r'\\stop'


			if re.match(re1, text):
				print("re1 matched!")

			if re.match(re2, text):
				# would not match, as '\' is a special character in regex and should be escaped, as well
				print("re2 matched!")

			if re.match(re3, text):
				print("re3 matched!")
		</code></pre>
	</section>
	<section><h3>the <code><a href="https://docs.python.org/3/library/re.html#re.compile">re.compile()</a></code> method</h3>
		<dl class="fa">
			<dt>Compiles a regular expression pattern into a regular expression object, which can be used for matching using its methods for matching and search</dt>
		</dl>
		<pre><code rel="Python" class="python">
			import re

			text = "ABRACADABRA"

			regex = re.compile(r'aca', re.I)

			if regex.search(text):
				print('Match')
		</code></pre>
	</section>
</section>


<section data-min="20"><h1>Regex Match Methods</h1></section>
<section><h2>Regex Match Methods</h2>
	<section><h3><a href="https://docs.python.org/3/library/re.html#re.regex.search">regex.search(string[, start[, end]]))</a></h3>
		<dl class="fa">
			<dt>Scan through string looking for the  where this regular expression produces a match.</dt>
			<dt>If match produced => returns a corresponding <a href="https://docs.python.org/3/library/re.html#match-objects">match object</a></dt>
			<dt>If string does not matches the pattern => return <span class="note">None</span></dt>
			<dt>optional parameters:</dt>
			<dd><i>start</i> - the index where the search should start</dd>
			<dd><i>end</i> - the index where the search should ends</dd>
		</dl>
	</section>
	<section><h3><a href="https://docs.python.org/3/library/re.html#re.regex.search">regex.search(string[, start[, end]]))</a> - example</h3>
		<pre><code rel="Python" class="python">
			import re

			text = "123abc456"
			rx = re.compile('abc')

			res = rx.search(text) # will match
			res = rx.search(text,3) # will match, 'a' is on index 3 in text
			res = rx.search(text,4) # would NOT match
		</code></pre>
	</section>
	<section><h3><a href="https://docs.python.org/3/library/re.html#re.regex.match">regex.match(string[, start[, end]])</a></h3>
		<dl class="fa">
			<dt>Matches only <span class="note">on the beginning of the string</span></dt>
			<dt>If you want to locate a match anywhere in string, use search() instead</dt>
			<dt>Reference: <a href="https://docs.python.org/3/library/re.html#search-vs-match">search-vs-match @python docs</a></dt>
			<!-- <dt>For the rest - acts like regex.search() method</dt> -->
		</dl>
	</section>
	<section><h3><a href="https://docs.python.org/3/library/re.html#re.regex.match">regex.match(string[, start[, end]])</a> - example</h3>
		<pre><code rel="Python" class="python">
			text = "123abc456"
			rx = re.compile('abc')

			res = rx.match(text)

			res = rx.match(text) # will NOT match, 'abc' is not in the beginning
			res = rx.match(text,3) # will match, as matching starts from index 3
		</code></pre>
	</section>
	<section><h3><a href="https://docs.python.org/3/library/re.html#re.regex.findall">regex.findall(string[, pos[, endpos]])</a></h3>
		<dl class="fa">
			<dt>Returns <span class="note"> a list of strings</span> containing all non-overlapping matches of regex in the string</dt>
			<dt>The string is scanned left-to-right, and matches are returned in the order found</dt>
		</dl>
	</section>
	<section><h3><a href="https://docs.python.org/3/library/re.html#re.regex.findall">regex.findall(string[, pos[, endpos]])</a> -example</h3>
		<pre><code rel="Python" class="python">
			text = "123abc456abcabc"
			rx = re.compile('abc')

			res = rx.findall(text) # ['abc', 'abc', 'abc']
			res = rx.findall(\dtext) # ['3abc', '6abc']
		</code></pre>
	</section>
	<section><h3>Other Matching Methods</h3>
		<dl class="fa">
			<dt><a href="https://docs.python.org/3/library/re.html#re.regex.finditer">regex.finditer(string[, pos[, endpos]])</a></dt>
			<dt><a href="https://docs.python.org/3/library/re.html#re.regex.fullmatch">regex.fullmatch(string[, pos[, endpos]])</a></dt>
			<dt><a href="https://docs.python.org/3/library/re.html#re.regex.sub">regex.sub(repl, string, count=0)</a></dt>
			<dt><a href="https://docs.python.org/3/library/re.html#re.regex.subn">regex.subn(repl, string, count=0)</a></dt>
		</dl>
	</section>
	<section><h3>re module-level matching methods</h3>
		<dl class="fa">
			<dt>The methods described above, was methods of an Regular Expression Objects</dt>
			<dt>Python has the same methods defined for re module, like:</dt>
			<dd><a href="https://docs.python.org/3/library/re.html#re.search">re.search(pattern, string, flags=0)</a></dd>
			<dd>and so on...</dd>
			<dt>The difference is that we must pass the pattern string as first argument, and optional flags at the end.</dt>
		</dl>
	</section>
	<section><h3>When to use Regex Match Methods?</h3>
		<dl class="fa">
			<dt>The modlule-level match functions compile the given regex string, and keep it in its cache. So future calls using the same RE won’t need to parse the pattern again</dt>
			<dt>But when you use the function in a loop, the function itself will be needlessly called, that's why in loops, it is better to use the precompiled regex.</dt>
		</dl>
	</section>
</section>


<section data-min="10"><h1><a href="https://docs.python.org/3/library/re.html#match-objects">Match Objects</a></h1></section>
<section><h2>The Match Object</h2>
	<section><h3>Overview</h3>
		<dl class="fa">
			<dt>match() and search() methods returns a <a href="https://docs.python.org/3/library/re.html#match-objects">Match Object</a></dt>
			<dt>It always have a boolean value of True</dt>
			<dt>It contains useful information about the matched strings.</dt>
		</dl>
	</section>
	<section><h3><a href="https://docs.python.org/3/library/re.html#match-objects">Match Object</a> Methods</h3>
		<table style="width: 110%">
			<tr><th>Method/Attribute</th><th>Purpose</th></tr>
			<tr><td>group()</td><td>Return the string matched by the RE</td></tr>
			<tr><td>groups()</td><td>Return a tuple containing all the subgroups of the match</td></tr>
			<tr><td>start()</td><td>Return the starting position of the match</td></tr>
			<tr><td>end()</td><td>Return the ending position of the match</td></tr>
			<tr><td>span()</td><td>Return a tuple containing the (start, end) positions of the match</td></tr>
		</table>
		<p>More methods: <a href="https://docs.python.org/3/library/re.html#match-objects">Match Object</a></p>
	</section>
	<section><h3><a href="https://docs.python.org/3/library/re.html#match-objects">Match Object</a> Methods - example</h3>
		<pre><code rel="Python" class="python">
			text = "123abc456abc"
			rx = re.compile('(\d+)(abc)')

			res = rx.match(text)
			if res:
				print("res.group():", res.group()) #123abc
				print("res.groups():", res.groups()) #('123', 'abc')
			else:
				print("No match!")
		</code></pre>
		<p class="note">We will discuss capturing groups on next slides</p>
	</section>
</section>


<section data-min="20"><h1>Regex Syntax</h1></section>
<section><h2>Regex Syntax</h2>
	<section><h3>Special Characters</h3>
		<p>Only next characters has special meaning in Regex:</p>
		<code class="note">^ $ \ . * + ? ( ) [ ] { } |</code>
		<p>They can be combined with ordinary characters to change their meaning too</p>
		<p>If we want to match <b>literally</b> a special character we have to escape it with backslash <code>'\'</code></p>
	</section>
	<section><h3>Matching Special Characters - example</h3>
		<pre><code rel="Python" class="python">
			import re

			text = "try to match: 2+3"
			rx = re.compile('2\+3')

			res = rx.search(text)
			if res:
				print( res.group())
		</code></pre>
	</section>
</section>

<section data-min="5"><h1>Quantifiers</h1></section>
<section><h2>Quantifiers</h2>
	<section><h3>Overview</h3>
		<table style="font-size: .9em">
			<tr><th>Quantifier</th><th>Description</th></tr>
			<tr><td><i>r</i> <b class="note">*</b></td><td><i>r</i> match <b>0</b> or <b>more times</b></td></tr>
			<tr><td><i>r</i> <b class="note">+</b></td><td><i>r</i> match <b>1</b> or <b>more times</b></td></tr>
			<tr><td><i>r</i> <b class="note">?</b></td><td><i>r</i> match <b>0</b> or <b>1</b>time</td></tr>
			<tr><td><i>r</i> <b class="note">{n}</b></td><td><i>r</i> match <b>exactly <i>n</i> times</b></td></tr>
			<tr><td><i>r</i> <b class="note">{n,m}</b></td><td><i>r</i> match between <b>n</b> and <b>m</b> times (n, m are positive)</td></tr>
		</table>
		<p class="note"><code>r</code> can be any regex!</p>
	</section>
	<section><h3>Quantifiers (greedy and non-greedy match)</h3>
		<dl class="fa">
			<dt>The quantifiers are <span class="note">greedy</span>, meaning they will match the maximum part of the string they can:</dt>
			<pre><code rel="Python" class="python">
				matched = re.search(r'a.*a','ala bala' );
				print(matched)
				# match='ala bala', but not 'ala'
			</code></pre>
		</dl>
	</section>
	<section><h3>Quantifiers (greedy and non-greedy match)</h3>
		<dl class="fa">
			<dt>We can make them <span class="note">non-greedy</span>, if we suffix them with '<code class="note">?</code>'</dt>
			<pre><code rel="Python" class="python">
				matched = re.search(r'a.*?a','ala bala' );
				print(matched)
				#match='ala'
			</code></pre>
		</dl>
	</section>
	<section><h3>'*'quantifier - example</h3>
		<pre><code rel="Python" class="python">
			import re

			string = 'ala bala'

			matched = re.findall(r'a.*a',string ) # greedy
			print(matched)
			#OUTPUT: ['ala bala']

			matched = re.findall(r'a.*?a',string ) # non-greedy
			print(matched)
			#OUTPUT: ['ala', 'ala']

			matched = re.findall(r'.*?',string ) # non-gready
			print(matched)
			#OUTPUT: ['', '', '', '', '', '', '', '', ''
		</code></pre>
	</section>
	<section><h3>{n,m} quantifier - example</h3>
		<pre><code rel="Python" class="python">
			import re

			matched = re.findall(r'\d{2,4}','123456789' ) # gready
			print(matched)
			# OUTPUT: ['1234', '5678']

			matched = re.findall(r'\d{2,4}?','123456789' ) # non-gready
			print(matched)
			#OUTPUT: ['12', '34', '56', '78']
		</code></pre>
	</section>
</section>



<section data-min="5"><h1>Character Sets</h1></section>
<section><h2>Character Sets</h2>
	<section><h3>Overview</h3>
		<dl class="fa">
				<dt>The square brackets are used to define a character set. Like: <code><b>[</b>abc<b>]</b></code> (will match 'a' or 'b' or 'c').</dt>
				<dt class="note">The character set itself match only one symbol!</dt>
				<dt>Symbols inside brackets are the elements of set.</dt>
				<dt>Special characters lose their special meaning inside sets</dt>
				<dt>The hyphen (<code>-</code>), when it is between 2 symbols, has special meaning inside the character class  - it defines a range. Like: <code>[0-9]</code>. If it is in the end, it is considered as a hyphen.</dt>
		</dl>
	</section>
	<section><h3>Character Sets Description</h3>
		<table>
			<tr><th>Character set</th><th>Description</th></tr>
			<tr><td><code class="note">[abc]</code></td><td>Match any one of the symbols listed ('a' or 'b' or 'c')</td></tr>
			<tr><td><code class="note">[a-z]</code></td><td>Match any symbol, from 'a' till 'z' (i.e. any lower Latin letter)</td></tr>
			<tr><td><code class="note">[^abc]</code></td><td>Match any symbol, except 'a or 'b' or 'c' (i.e. the <code><b>^</b></code> negates the characters in the set)</td></tr>
		</table>
	</section>
	<section><h3>Character Sets examples</h3>
		<pre><code rel="Python" class="python">
			import re

			# match any one of the vocals
			matched = re.findall(r'[aeiouy]','astroid' );
			print(matched)
			#OUTPUT: ['a', 'o', 'i']

			# match any consecutive vocals - one or more times
			matched = re.findall(r'[aeiouy]+','astroid' );
			print(matched)
			#OUTPUT: ['a', 'oi']

			# match bg mobile phone numbers
			matched = re.findall('\+3598[7-9][0-9]{7}', '+359888123456');
			print(matched)
			#OUTPUT: ['+359888123456']

			# match digit or hyphen:
			matched = re.findall('[1-5-]', '12-34');
			print(matched)
			#OUTPUT: ['1', '2', '-', '3', '4']
		</code></pre>
	</section>
	<section><h3>Character Sets Negation - examples</h3>
		<pre><code rel="Python" class="python">
			import re

			# match any non-vocal:
			matched = re.findall(r'[^aeiouy]','astroid' );
			print(matched)
			#OUTPUT: ['s', 't', 'r', 'd']
		</code></pre>
	</section>
</section>


<section data-min="5"><h1>Character classes</h1></section>
<section><h2>Character classes</h2>
	<section><h3>Character classes</h3>
		<dl class="fa">
				<dt>Character classes can be regarded as shorthands for some of the most used  character sets.</dt>
				<dt>In python3 they work only on any Unicode symbols.</dt>
				<dd>You can use the <a href="https://docs.python.org/3/library/re.html#re.ASCII">re.ASCII/(?a)</a>  flag to specify that you want only ASCII symbols to be matched.</dd>
		</dl>
	</section>
	<section><h3>Character classes</h3>
		<table style="font-size: .8em">
			<tr><th>Char class</th><th>Description</th></tr>
			<tr><td><code class="note">.</code></td><td>Match <span class="note">any</span> character, except newline/line terminator. You can use the <a href="https://docs.python.org/3/library/re.html#re.S">re.DOTALL/(?s)</a> to match the new line, as well</td></tr>
			<tr><td><code class="note">\w</code></td><td>Matches Unicode word characters; this includes most characters that can be part of a word in any language, as well as numbers and the underscore.<br>If the ASCII flag is used, only [a-zA-Z0-9_] is matched </td></tr>
			<tr><td><code class="note">\d</code></td><td>Matches any Unicode decimal digit, which includes [0-9], and also many other digit characters<br>If the ASCII flag is used, only [0-9] is matched</td></tr>
			<tr><td><code class="note">\s</code></td><td>Matches any Unicode whitespace characters (which includes [ \t\n\r\f\v], and also many other characters,</td></tr>
		</table>
	</section>
	<section><h3>Character classes example</h3>
		<pre><code rel="Python" class="python">
			import re

			# match bg mobile phone numbers
			matched = re.findall('\+3598[7-9]\d{7}', '+359888123456');
			print(matched)
			#OUTPUT: ['+359888123456']
		</code></pre>
	</section>
	<section><h3>Character classes example</h3>
		<pre><code rel="Python" class="python">
			import re

			strings = ['petrov42','42petrov','ivan_pterov']
			rx = re.compile('[a-z]\w+')

			for string in strings:
				matched = rx.search(string);
				print("{} matched in {}".format(matched.group(),string) )
			#OUTPUT:
			#petrov42 matched in petrov42
			#petrov matched in 42petrov
			#ivan_pterov matched in ivan_pterov
		</code></pre>
	</section>
	<section><h3>Character classes example</h3>
		<pre><code rel="Python" class="python">
			string = """line1
			line2
			line3 line4"""

			matched = re.findall('line\d\s', string);
			print(matched)

			#OUTPUT: ['line1\n', 'line2\n', 'line3 ']
		</code></pre>
	</section>
</section>


<section data-min="5"><h1>Modifiers/Flags</h1></section>
<section><h2>Modifiers/Flags</h2>
	<section><h3>Modifiers/Flags</h3>
		<dl class="fa">
			<dt>Flags reflects how the regular expression is executed.</dt>
			<dt>They are available in the re module with a long name such as re.IGNORECASE or with a short, one-letter form such as re.I.</dt>
			<dt>Multiple flags can be specified by bitwise OR-ing them. For example <code>re.I|re.M</code> sets both the I and M flags.</dt>
			<dt>These flags are set by passing the <i>flags</i> argument to the re.compile() method</dt>
			<dt>Flags can be also set in the regular expression itself, using (?aiLmsux) syntax at the beginning of the regex</dt>
		</dl>
	</section>
	<section><h3>Modifiers/Flags list</h3>
		<table >
			<tr><th>In reges</th><th>As param</th><th>Description</th></tr>
			<tr><td>(?i)</td><td>re.I</td><td>case-<b>i</b>nsensitive matching</td></tr>
			<tr><td>(?m)</td><td>re.M</td><td><b>m</b>ultiline matching</td></tr>
			<tr><td>(?s)</td><td>re.S</td><td>Make the '<b>.</b>' to match any character at all, including a newline</td></tr>
			<tr><td>(?x)</td><td>re.X</td><td>Allows to write readable regexes by using spaces and comments('#') in the regex. More on: <a href="https://docs.python.org/3/library/re.html#re.X">re.X</a></td></tr>
		</table>
	</section>
	<section><h3>Modifiers/Flags example</h3>
		<pre><code rel="Python" class="python">
			import re

			text = """123
			ABC
			456"""
			rx = re.compile('(?is)123.abc')

			res = rx.search(text)
			if res:
				print(res.group(0))
			else:
				print("No match!")
		</code></pre>
	</section>
</section>


<section data-min="5"><h1>Anchors and Boundaries</h1></section>
<section><h2>Anchors and Boundaries</h2>
	<section><h3>Overview</h3>
		<dl class="fa">
			<dt>They specify a <b>position</b> in the string where a match should occurs.</dt>
			<dt>They are zero-width, i.e.when matched they do NOT consume characters from the string.</dt>
		</dl>
	</section>
	<section><h3>Anchors and Boundaries</h3>
		<table style="font-size: .9em">
			<tr><th>Anchor</th><th>Description</th></tr>
			<tr><td class="note">^</td><td>Matches the <span class="note">beginning</span> of the string (or the line, if <b>m</b> flag is used)</td></tr>
			<tr><td class="note">$</td><td>Matches the <span class="note">end</span> of the string (or the line, if <b>m</b> flag is used)</td></tr>
			<tr><td class="note">\b</td><td>Matches on word boundaries, i.e. between <i>word</i>(\w) and <i>non-word</i>(\W) characters.<br>Note that the <b>start</b> and <b>end</b> of string are considered as non-word characters.</td></tr>
			<tr><td class="note">\Z</td><td>Matches only at the end of the string.</td></tr>
		</table>
	</section>
	<section><h3>Anchors and Boundaries example</h3>
		<pre><code rel="Python" class="python">
			import re

			strings = [
				'',
				'a',
				'@',
				'@a',
				'aa',
				'a!',
				'a,a',
			]
			rx = re.compile(r'\b');

			for string in strings:
				res = rx.findall(string)
				print("{} word bounders counted in {}".format(len(res), string))
			#OUTPUT
			#0 word bounders counted in
			#2 word bounders counted in a
			#0 word bounders counted in @
			#2 word bounders counted in @a
			#2 word bounders counted in aa
			#2 word bounders counted in a!
			#4 word bounders counted in a,a
		</code></pre>
	</section>
	<section><h3>Anchors and Boundaries example</h3>
		<pre><code rel="Python" class="python">
			strings = [
				'ana',
				'ana bel',
			]
			rx = re.compile(r'^a\w+a$');

			for string in strings:
				res = rx.findall(string)
				print("{} matches in {}".format(len(res), string))
			#OUTPUT:
			#1 matches in ana
			#0 matches in ana bel
		</code></pre>
	</section>
	<!-- <section><h3>Anchors and Boundaries example</h3>
		<pre><code rel="Python" class="python">
			var re = /\b[\w-]+\b/gi;
			var strings = [
				'one two three four, five, six. Seven!',
				'one-two,three!',
			];
			strings.forEach(str=>{
				var res = str.match(re);
				res && console.log(`${res.length} matches in '${str}'`)
			});
			// 7 matches in 'one two three four, five, six. Seven!'
			// 2 matches in 'one-two,three!'
		</code></pre>
	</section> -->
</section>


<section data-min="5"><h1>Alternation</h1></section>
<section><h2>Alternation</h2>
	<section><h3>Alternation</h3>
		<dl class="fa">
			<dt>With alternation we can match one <span class="note">or</span> another regexp!</dt>
		</dl>
		<table>
			<tr><th>Alternation</th><th>Description</th></tr>
			<tr><td>r1<span class="note">|</span>r2</td><td>Matches if r1 OR r2 is matched</td></tr>
		</table>
	</section>
	<!-- <section><h3>Alternation example</h3>
		<pre><code rel="Python" class="python">
			// NB: this is not example of good practice for grouping regex. Why? => check next slides
			var re = /\b(straw|rasp)?berries/;
			var strings = [
				'Icecream with strawberries? Yes!',
				'Icecream with blueberries? No!',
				'Icecream with raspberries? Yes!',
				'Icecream with berries? Yes!',
			]

			strings.forEach(str=> str.match(re) ?
				console.log(`${str} YES! YES!`) : console.log(`${str} NO! NO!`)
			)
			// Icecream with strawberries? Yes! YES! YES!
			// Icecream with blueberries? No! NO! NO!
			// Icecream with raspberries? Yes! YES! YES!
			// Icecream with berries? Yes! YES! YES!
		</code></pre>
	</section> -->
</section>


<section data-min="5"><h1>Grouping and capturing</h1></section>
<section><h2>Grouping and capturing</h2>
	<section><h3>Grouping and back references</h3>
		<dl class="fa" style="font-size: .8em">
			<dt>Brackets: <span class="note">(</span> and <span class="note">)</span>, play a dual role in regex!</dt>
			<dt>They can be used for grouping regexes.Like: </dt>
			<dd><code><b>/(r1|r2)r3/</b></code> => match <code><b>r1r3</b></code> OR <code><b>r2r3</b></code>, but not <code><b>r1r2r3</b></code></dd>
			<dt>Or they can be used to <span class="note">capture</span> (remember) the matched part of the string. Like: </dt>
			<dd><code><b>/(r1)r2/</b></code> => match <code><b>r1r2</b></code> and capture the part of the string that matched <code><b>r1</b></code></dd>
			<dt>If you just want to <span class="note">group regexes, without capturing the match</span>, you should explicitly state that by: </dt>
			<dd><code>(<span class="note">?:</span>r1|r2)</code> => match <code><b>r1</b></code> or <code><b>r2</b></code> but <span class="note"><b>do not capture</b></span> the match</dd>
			<dt class="note">NB! Capturing is slow and memory consuming! If you need the parenthesis just for grouping- always use the <b>?:</b> prefix.</dt class="note">
		</dl>
	</section>
	<section><h3>Capturing - example</h3>
		<pre><code rel="Python" class="python">
			import re

			user = 'Ivan Ivanov: +359 887123456'

			rx = re.compile("""(?x)
				([A-Z]\w+)\s+   # capture first name
				([A-Z]\w+):\s+  # capture sur name
				\+(\d{3})\s     # capture country code
				(\d{6,8})       # capture number
			""")

			res = rx.search(user)
			if res:
				i = 0
				for t in res.groups():
					print("Capture {}: {}".format(i,t))
					i+=1

			#OUTPUT:
			#Capture 0: Ivan
			#Capture 1: Ivanov
			#Capture 2: 359
			#Capture 3: 88712345
		</code></pre>
	</section>
	<section><h3>Grouping regexes example</h3>
		<pre><code rel="Python" style="font-size: .8em;">
			import re

			strings = [
				'Icecream with strawberries?',
				'Icecream with blueberries?',
				'Icecream with raspberries?',
				'Icecream with strawraspberries?',
				'Icecream with berries?',
			]
			rx = re.compile(r'\b(?:straw|rasp)?berries');

			for string in strings:
				res = rx.search(string)
				if res:
					print('{} YES!'.format(string))
				else:
					print('{} NO!'.format(string))
			#OUTPUT:
			#Icecream with strawberries? YES!
			#Icecream with blueberries? NO!
			#Icecream with raspberries? YES!
			#Icecream with strawraspberries? NO!
			#Icecream with berries? YES!
		</code></pre>
	</section>
</section>
<!--   <section><h3>Assertions</h3>
		<p>Gives the possibility to match a regex only if it is followed or not by something. I.e. we can make lookahead!</p>
		<p class="advanced"></p>
	</section> -->

<section data-min="5"><h1>Resources</h1></section>
<section><h2>Videos</h2>
	<section>
		<p>Reg(exp){2}lained/: Demystifying Regular Expressions by Lea Verou</p>
		<iframe width="767" height="431" src="https://www.youtube.com/embed/EkluES9Rvak" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
	</section>
</section>

<section><h3>Online Regex Testers for Python</h3>
	<dl class="fa">
		<dt><a href="https://regex101.com/">regex101.com - Online regex tester and debugger: PHP, PCRE, Python, Golang and</a></dt>
	</dl>
</section>

<section id="hw"><h1>Exercises</h1></section>
<section><h2>Online Chalanges</h2>
	<section>
		<dl class="fa">
			<dt><a href="https://www.hackerrank.com/domains/regex">Practice Regex @Hackerrank</a></dt>
		</dl>
	</section>
</section>

<!--
<section><h3>Submission</h3>
	<dl class="fa">
		<dt>Please, prefix your filenames/archive with your name initials, before sending.</dt>
		<dd>For instance: <b>iep_task1.py</b> or <b>iep_tasks.rar</b></dd>
		<dt>Send files to <a href="mailto:progressbg.python.course@gmail.com?Subject=HW: regexes">progressbg.python.course@gmail.com</a></dt>
	</dl>
</section> -->



<section class="disclaimer" data-background="/ProgressBG-Python-UniCredit-Slides/outfit/images/for_slides/the_end_on_sand.jpg">
	 <p>These slides are based on</p>
	 <p>customised version of </p>
	 <p><a href="http://hakim.se/">Hakimel</a>'s <a href="http://lab.hakim.se/reveal-js">reveal.js</a></p>
	 <p>framework</p>
</section>
<!--
########################################################
##################### SLIDES END   #####################
########################################################
-->
		</div>
	</div>
	<!-- Custom processing -->
	<script src="/ProgressBG-Python-UniCredit-Slides/outfit/js/slides.js"></script>
	<!-- external scripts -->
	<script src="/ProgressBG-Python-UniCredit-Slides/lib/reveal.js/lib/js/head.min.js"></script>
	<script src="/ProgressBG-Python-UniCredit-Slides/lib/reveal.js/js/reveal.js"></script>
	 <!-- init reveal -->
	<script>
		// Full list of configuration options available at:
		// https://github.com/hakimel/reveal.js#configuration
		var highlightjsTabSize = '  ';
		Reveal.initialize({
			controls: true,
			progress: true,
			slideNumber: 'c/t',
			keyboard: true,
			history: true,
			center: true,
			width: 1920,
			height: 1280,
			// Bounds for smallest/largest possible scale to apply to content
			// minScale: .5,
			maxScale: 1,
			// slide transition
			transition: 'concave', // none/fade/slide/convex/concave/zoom
			// Factor of the display size that should remain empty around the content
			margin: 0.1,
			// shift+maous click to zoom in/out element
			zoomKey: 'ctrl',
			// theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
			// transition: Reveal.getQueryHash().transition || 'default'
			// Optional reveal.js plugins
			dependencies: [
				{ src: '/ProgressBG-Python-UniCredit-Slides/lib/reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
				{ src: '/ProgressBG-Python-UniCredit-Slides/lib/reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
				{ src: '/ProgressBG-Python-UniCredit-Slides/lib/reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
				{ src: '/ProgressBG-Python-UniCredit-Slides/lib/reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.configure(); hljs.initHighlightingOnLoad(); } },
				{ src: '/ProgressBG-Python-UniCredit-Slides/lib/reveal.js/plugin/zoom-js/zoom.js', async: true },
				{ src: '/ProgressBG-Python-UniCredit-Slides/lib/reveal.js/plugin/notes/notes.js', async: true }
			]
		});
	</script>
</body>
</html>
